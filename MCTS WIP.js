//MCTS
class MCTSNode{constructor(a,c){this.moves=a;this.parent=c;this.wins=this.visits=0;this.numUnexpandedMoves=a.length;this.children=Array(this.numUnexpandedMoves).fill(null)}}
class MCTS{constructor(a,c,b,d){this.game=a;this.player=c;this.iterations=b;this.exploration=d;void 0==this.iterations&&(this.iterations=500);void 0==this.exploration&&(this.exploration=1.41)}selectMove(){var a=this.game.cloneState(),c=this.game.moves();const b=new MCTSNode(c,null);for(let e=0;e<this.iterations;e++){this.game.setState(a);var d=this.game.cloneState();this.game.setState(d);d=this.selectNode(b);this.game.gameOver()&&this.game.winner()!=this.player&&-1!=this.game.winner()&&(d.parent.wins=
Number.MIN_SAFE_INTEGER);d=this.expandNode(d);this.playout(d);let f;f=this.game.winner()==this.player?1:0;this.backprop(d,f)}c=c[this.getBestChildIndex(b)];this.game.setState(a);console.log(b);a=this.getPv(b);return{move:c,pv:a,stats:{wins:b.wins,visits:b.visits}}}selectNode(a){const c=this.exploration;for(;0==a.numUnexpandedMoves;){var b=-Infinity;let f=-1,g=a.visits;for(let h in a.children){var d=a.children[h],e=d.visits;d=this.game.getPlayerTurn()==this.player?d.wins:-d.wins;e=this.computeUCB(d,
e,c,g);e>b&&(b=e,f=h)}b=this.game.moves();this.game.playMove(b[f]);a=a.children[f];if(this.game.gameOver())break}return a}expandNode(a){if(this.game.gameOver())return a;var c=this.game.moves();const b=this.selectRandomUnexpandedChild(a);this.game.playMove(c[b]);c=this.game.moves();c=new MCTSNode(c,a);a.children[b]=c;--a.numUnexpandedMoves;return c}playout(){for(;!this.game.gameOver();){const a=this.greedyMove();this.game.playMove(a)}return this.game.winner()}backprop(a,c){for(;null!=a;)a.visits+=
1,a.wins+=c,a=a.parent}selectRandomUnexpandedChild(a){const c=Math.floor(Math.random()*a.numUnexpandedMoves);let b=-1;for(let d in a.children)if(null==a.children[d]&&(b+=1),b==c)return d}computeUCB(a,c,b,d){return a/c+b*Math.sqrt(Math.log(d)/c)}getBestChildIndex(a){let c=-Infinity,b=-1;for(let d in a.children){const e=a.children[d];null!=e&&e.wins>c&&(c=e.wins,b=d)}return b}getPv(a){const c=[];for(;0!=a.children.length;){let b=this.getBestChildIndex(a);c.push(a.moves[b]);a=a.children[b];if(void 0==
a)break}return c}lowestRankCard(a){const c=b=>{if(1>=b.length)return b;let d=b[0],e=[],f=[];for(let g=1;g<b.length;g++)b[g].Value<d.Value?e.push(b[g]):f.push(b[g]);return[...c(e),d,...c(f)]};return c(a)[0]}greedyMove(){const a=this.game.moves();if(1===a.length)return a[0];const c=a.filter(e=>"object"===typeof e);var b=Math.floor(Math.random()*a.length);if(.3>Math.random())return a[b];const d=this.game.getTrump();b=c.filter(e=>e.Type!=d);return 0===b.length?!this.game.endGame()&&a.includes("pass")?
a[a.length-1]:this.lowestRankCard(c):this.lowestRankCard(b)}}

//GAME
//------------------------------------------------------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------------------------------------------------------
class Durak{constructor(b,a,d,c,e=[],f=[],g=null){this.state={playerCards:b,playerTurn:a,trump:d,cardsOnTable:c,attackCards:e,deck:f,lowerTrump:g,endGame:!0,winner:-1,gameOver:!1,isTaking:!1}}getState(){return this.state}setState(b){this.state=b}getPlayerTurn(){return this.state.playerTurn}getTrump(){return this.state.trump}endGame(){return this.state.endGame}cloneState(){JSON.parse(JSON.stringify(this.state))}static sameCard(b,a){return b.Value===a.Value&&b.Type===a.Type?!0:!1}moves(){let b=[];if(0===
this.state.playerCards[this.state.playerTurn].length&&0===this.state.deck.length)return this.state.winner=this.state.playerTurn,this.state.gameOver=!0,["Game Over"];if(0===this.state.cardsOnTable.length)b=this.state.playerCards[this.state.playerTurn];else if(0===this.state.attackCards.length||this.state.isTaking){if(this.state.isTaking&&this.state.attackCards.length===this.state.playerCards[0===this.state.playerTurn?1:0].length)return["pass"];b=this.state.playerCards[this.state.playerTurn].filter(c=>
this.state.cardsOnTable.some(e=>e.Value===c.Value));b.push("pass")}else if(0!==this.state.attackCards.length){if(this.state.attackCards[0].Type!==this.state.trump)for(var a=0;a<this.state.playerCards[this.state.playerTurn].length;a++){var d=this.state.playerCards[this.state.playerTurn][a].Type;let c=this.state.playerCards[this.state.playerTurn][a].Value;(d===this.state.attackCards[0].Type&&c>this.state.attackCards[0].Value||d===this.state.trump)&&b.push(this.state.playerCards[this.state.playerTurn][a])}else for(a=
0;a<this.state.playerCards[this.state.playerTurn].length;a++)d=this.state.playerCards[this.state.playerTurn][a].Value,this.state.playerCards[this.state.playerTurn][a].Type===this.state.attackCards[0].Type&&d>this.state.attackCards[0].Value&&b.push(this.state.playerCards[this.state.playerTurn][a]);b.push("take")}return b}playMove(b){switch(b){case "pass":if(this.state.isTaking){let a=0===this.state.playerTurn?1:0;this.state.cardsOnTable.forEach(d=>this.state.playerCards[a].push(d));this.state.isTaking=
!1;this.takeCards(this.state.playerTurn)}else this.takeCards(this.state.playerTurn),this.state.playerTurn=0===this.state.playerTurn?1:0;this.state.cardsOnTable=[];this.state.attackCards=[];break;case "take":this.state.isTaking=!0;this.state.playerTurn=0===this.state.playerTurn?1:0;break;default:this.state.isTaking?(this.state.cardsOnTable.push(b),this.state.attackCards.push(b),this.state.playerCards[this.state.playerTurn]=this.state.playerCards[this.state.playerTurn].filter(a=>!Durak.sameCard(a,b)),
0===this.state.playerCards[this.state.playerTurn].length&&0===this.state.deck.length&&(this.state.winner=this.state.playerTurn,this.state.gameOver=!0)):(this.state.cardsOnTable.push(b),this.state.playerCards[this.state.playerTurn]=this.state.playerCards[this.state.playerTurn].filter(a=>!Durak.sameCard(a,b)),0===this.state.playerCards[this.state.playerTurn].length&&0===this.state.deck.length?(this.state.winner=this.state.playerTurn,this.state.gameOver=!0):0===this.state.attackCards.length?(this.state.attackCards.push(b),
this.state.playerTurn=0===this.state.playerTurn?1:0):1===this.state.attackCards.length?(this.state.attackCards.shift(),this.state.playerTurn=0===this.state.playerTurn?1:0):this.state.attackCards.shift())}}takeCards(b){function a(d,c){if(!c.endGame){var e=6-c.playerCards[d].length;for(let f=0;f<e;f++){if(0===c.deck.length){if(null==c.lowerTrump){c.endGame=!0;break}c.deck.push(c.lowerTrump);c.lowerTrump=null}c.playerCards[d].push(c.deck[0]);c.deck.shift()}}}b?(6>this.state.playerCards[1].length&&a(1,
this.state),6>this.state.playerCards[0].length&&a(0,this.state)):(6>this.state.playerCards[0].length&&a(0,this.state),6>this.state.playerCards[1].length&&a(1,this.state))}gameOver(){return this.state.gameOver}winner(){return this.state.winner}}class Card{constructor(b,a){this.Value=b;this.Type=a}getValue(){return this.Value}getType(){return this.Type}}

////PEREVODNOI

//------------------------------------------------------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------------------------------------------------------
class DurakReverse{constructor(a,b,c,d,e=[],f=[],g=null,h=!0){this.state={playerCards:a,playerTurn:b,trump:c,cardsOnTable:d,attackCards:e,deck:f,lowerTrump:g,endGame:h,winner:-1,gameOver:!1,isTaking:!1}}getState(){return this.state}setState(a){this.state=a}getPlayerTurn(){return this.state.playerTurn}getTrump(){return this.state.trump}endGame(){return this.state.endGame}cloneState(){return JSON.parse(JSON.stringify(this.state))}static sameCard(a,b){return a.Value===b.Value&&a.Type===b.Type?!0:!1}moves(){let a=
[];if(0===this.state.playerCards[this.state.playerTurn].length&&0===this.state.deck.length)return this.state.winner=this.state.playerTurn,this.state.gameOver=!0,["Game Over"];var b=0===this.state.playerTurn?1:0;if(0===this.state.cardsOnTable.length)a.push(...this.state.playerCards[this.state.playerTurn]),b=this.state.playerCards[b].length,1<b&&this.addPairMoves(a,b);else if(0===this.state.attackCards.length||this.state.isTaking){if(this.state.isTaking&&this.state.attackCards.length===this.state.playerCards[b].length)return["pass"];
a=this.state.playerCards[this.state.playerTurn].filter(e=>this.state.cardsOnTable.some(f=>f.Value===e.Value));a.push("pass")}else if(0!==this.state.attackCards.length){if(this.state.attackCards[0].Type!==this.state.trump)for(var c=0;c<this.state.playerCards[this.state.playerTurn].length;c++){var d=this.state.playerCards[this.state.playerTurn][c].Type;let e=this.state.playerCards[this.state.playerTurn][c].Value;(d===this.state.attackCards[0].Type&&e>this.state.attackCards[0].Value||d===this.state.trump)&&
a.push(this.state.playerCards[this.state.playerTurn][c])}else for(c=0;c<this.state.playerCards[this.state.playerTurn].length;c++)d=this.state.playerCards[this.state.playerTurn][c].Value,this.state.playerCards[this.state.playerTurn][c].Type===this.state.attackCards[0].Type&&d>this.state.attackCards[0].Value&&a.push(this.state.playerCards[this.state.playerTurn][c]);if(this.state.attackCards.length===this.state.cardsOnTable.length&&this.state.attackCards.length<this.state.playerCards[b].length)for(c=
this.state.playerCards[b].length,b=this.state.playerCards[this.state.playerTurn].filter(e=>e.Value==this.state.attackCards[0].Value),1<c-this.state.attackCards.length&&this.addPairMoves(b,c-this.state.attackCards.length),c=0;c<b.length;c++)a.push({action:"perevod",card:b[c]});a.push("take")}return a}playMove(a){switch(a){case "pass":if(this.state.isTaking){let b=0===this.state.playerTurn?1:0;this.state.cardsOnTable.forEach(c=>this.state.playerCards[b].push(c));this.state.isTaking=!1;this.takeCards(this.state.playerTurn)}else this.takeCards(this.state.playerTurn),
this.state.playerTurn=0===this.state.playerTurn?1:0;this.state.cardsOnTable=[];this.state.attackCards=[];break;case "take":this.state.isTaking=!0;this.state.playerTurn=0===this.state.playerTurn?1:0;break;default:if(this.state.isTaking)this.state.cardsOnTable.push(a),this.state.attackCards.push(a),this.state.playerCards[this.state.playerTurn]=this.state.playerCards[this.state.playerTurn].filter(b=>!DurakReverse.sameCard(b,a)),0===this.state.playerCards[this.state.playerTurn].length&&0===this.state.deck.length&&
(this.state.winner=this.state.playerTurn,this.state.gameOver=!0);else if("perevod"===a.action){if(Array.isArray(a.card))for(const b of a.card)this.state.cardsOnTable.push(b),this.state.attackCards.push(b),this.state.playerCards[this.state.playerTurn]=this.state.playerCards[this.state.playerTurn].filter(c=>!DurakReverse.sameCard(c,b));else this.state.cardsOnTable.push(a.card),this.state.attackCards.push(a.card),this.state.playerCards[this.state.playerTurn]=this.state.playerCards[this.state.playerTurn].filter(b=>
!DurakReverse.sameCard(b,a.card));this.state.playerTurn=0===this.state.playerTurn?1:0}else this.state.cardsOnTable.push(a),this.state.playerCards[this.state.playerTurn]=this.state.playerCards[this.state.playerTurn].filter(b=>!DurakReverse.sameCard(b,a)),0===this.state.playerCards[this.state.playerTurn].length&&0===this.state.deck.length?(this.state.winner=this.state.playerTurn,this.state.gameOver=!0):0===this.state.attackCards.length?(this.state.attackCards.push(a),this.state.playerTurn=0===this.state.playerTurn?
1:0):1===this.state.attackCards.length?(this.state.attackCards.shift(),this.state.playerTurn=0===this.state.playerTurn?1:0):this.state.attackCards.shift()}}takeCards(a){function b(c,d){if(!d.endGame){var e=6-d.playerCards[c].length;for(let f=0;f<e;f++){if(0===d.deck.length){if(null==d.lowerTrump){d.endGame=!0;break}d.deck.push(d.lowerTrump);d.lowerTrump=null}d.playerCards[c].push(d.deck[0]);d.deck.shift()}}}a?(6>this.state.playerCards[1].length&&b(1,this.state),6>this.state.playerCards[0].length&&
b(0,this.state)):(6>this.state.playerCards[0].length&&b(0,this.state),6>this.state.playerCards[1].length&&b(1,this.state))}gameOver(){return this.state.gameOver}winner(){return this.state.winner}addPairMoves(a,b){function c(e){var f=e.length;return Array(Math.pow(2,f)).fill().map((g,h)=>{g=-1;for(var k=[];++g<f;)h&1&&k.push(e[g]),h>>=1;return k}).slice(1)}var d=function(e){const f={};e.forEach(g=>{const {Value:h}=g;f[h]||(f[h]=[]);f[h].push(g)});return Object.values(f)}(a);for(const e of d)if(2===
e.length)a.push(e);else if(3===e.length){d=c(e);for(const f of d)2<=f.length&&f.length<=b&&a.push(f)}}}class Card{constructor(a,b){this.Value=a;this.Type=b}getValue(){return this.Value}getType(){return this.Type}}

