//MCTS
class MCTSNode{constructor(a,c){this.moves=a;this.parent=c;this.wins=this.visits=0;this.numUnexpandedMoves=a.length;this.children=Array(this.numUnexpandedMoves).fill(null)}}
class MCTS{constructor(a,c,b,d){this.game=a;this.player=c;this.iterations=b;this.exploration=d;void 0==this.iterations&&(this.iterations=500);void 0==this.exploration&&(this.exploration=1.41)}selectMove(){var a=this.game.cloneState(),c=this.game.moves();const b=new MCTSNode(c,null);for(let e=0;e<this.iterations;e++){this.game.setState(a);var d=this.game.cloneState();this.game.setState(d);d=this.selectNode(b);this.game.gameOver()&&this.game.winner()!=this.player&&-1!=this.game.winner()&&(d.parent.wins=
Number.MIN_SAFE_INTEGER);d=this.expandNode(d);this.playout(d);let f;f=this.game.winner()==this.player?1:0;this.backprop(d,f)}c=c[this.getBestChildIndex(b)];this.game.setState(a);console.log(b);a=this.getPv(b);return{move:c,pv:a,stats:{wins:b.wins,visits:b.visits}}}selectNode(a){const c=this.exploration;for(;0==a.numUnexpandedMoves;){var b=-Infinity;let f=-1,g=a.visits;for(let h in a.children){var d=a.children[h],e=d.visits;d=this.game.getPlayerTurn()==this.player?d.wins:-d.wins;e=this.computeUCB(d,
e,c,g);e>b&&(b=e,f=h)}b=this.game.moves();this.game.playMove(b[f]);a=a.children[f];if(this.game.gameOver())break}return a}expandNode(a){if(this.game.gameOver())return a;var c=this.game.moves();const b=this.selectRandomUnexpandedChild(a);void 0==c[b]&&console.log(this.game);this.game.playMove(c[b]);c=this.game.moves();c=new MCTSNode(c,a);a.children[b]=c;--a.numUnexpandedMoves;return c}playout(){for(;!this.game.gameOver();){const a=this.greedyMove();this.game.playMove(a)}return this.game.winner()}backprop(a,
c){for(;null!=a;)a.visits+=1,a.wins+=c,a=a.parent}selectRandomUnexpandedChild(a){const c=Math.floor(Math.random()*a.numUnexpandedMoves);let b=-1;for(let d in a.children)if(null==a.children[d]&&(b+=1),b==c)return d}computeUCB(a,c,b,d){return a/c+b*Math.sqrt(Math.log(d)/c)}getBestChildIndex(a){let c=-Infinity,b=-1;for(let d in a.children){const e=a.children[d];null!=e&&e.wins>c&&(c=e.wins,b=d)}return b}getPv(a){const c=[];for(;0!=a.children.length;){let b=this.getBestChildIndex(a);c.push(a.moves[b]);
a=a.children[b];if(void 0==a)break}return c}lowestRankCard(a){const c=b=>{if(1>=b.length)return b;let d=b[0],e=[],f=[];for(let g=1;g<b.length;g++)b[g].Value<d.Value?e.push(b[g]):f.push(b[g]);return[...c(e),d,...c(f)]};return c(a)[0]}greedyMove(){const a=this.game.moves();return 2>a.length?a[0]:this.getGreedyMove()}getGreedyMove(){this.game.moves();const a=this.game.moves().filter(d=>"object"===typeof d),c=this.game.getTrump(),b=a.filter(d=>d.Type!=c);return 0===b.length?this.lowestRankCard(a):this.lowestRankCard(b)}}
;
//GAME
class Durak{constructor(b,a,d,c,e=[],f=null,g=[]){this.state={playerCards:b,playerTurn:a,trump:d,cardsOnTable:c,attackCards:e,deck:g,lowerTrump:f,endGame:!1,winner:-1,gameOver:!1,isTaking:!1}}getState(){return this.state}setState(b){this.state=b}getPlayerTurn(){return this.state.playerTurn}getTrump(){return this.state.trump}cloneState(){return structuredClone(this.state)}static sameCard(b,a){return b.Value===a.Value&&b.Type===a.Type?!0:!1}moves(){let b=[];if(this.state.gameOver)return b;if(0===this.state.cardsOnTable.length)b=
this.state.playerCards[this.state.playerTurn];else if(0===this.state.attackCards.length){if(this.state.isTaking&&this.state.cardsOnTable.length>=this.state.playerCards[0===this.state.playerTurn?1:0].length)return["pass"];b=this.state.playerCards[this.state.playerTurn].filter(c=>this.state.cardsOnTable.some(e=>e.Value===c.Value));b.push("pass")}else if(0!==this.state.attackCards.length){if(this.state.attackCards[0].Type!==this.state.trump)for(var a=0;a<this.state.playerCards[this.state.playerTurn].length;a++){var d=
this.state.playerCards[this.state.playerTurn][a].Type;let c=this.state.playerCards[this.state.playerTurn][a].Value;(d===this.state.attackCards[0].Type&&c>this.state.attackCards[0].Value||d===this.state.trump)&&b.push(this.state.playerCards[this.state.playerTurn][a])}else for(a=0;a<this.state.playerCards[this.state.playerTurn].length;a++)d=this.state.playerCards[this.state.playerTurn][a].Value,this.state.playerCards[this.state.playerTurn][a].Type===this.state.attackCards[0].Type&&d>this.state.attackCards[0].Value&&
b.push(this.state.playerCards[this.state.playerTurn][a]);b.push("take")}return b}playMove(b){switch(b){case "pass":if(this.state.isTaking){let a=0===this.state.playerTurn?1:0;this.state.cardsOnTable.forEach(d=>this.state.playerCards[a].push(d));this.state.isTaking=!1;this.takeCards(this.state.playerTurn)}else this.takeCards(this.state.playerTurn),this.state.playerTurn=0===this.state.playerTurn?1:0;this.state.cardsOnTable=[];this.state.attackCards=[];break;case "take":this.state.attackCards=[];this.state.isTaking=
!0;this.state.playerTurn=0===this.state.playerTurn?1:0;break;default:this.state.isTaking?(this.state.cardsOnTable.push(b),this.state.playerCards[this.state.playerTurn]=this.state.playerCards[this.state.playerTurn].filter(a=>!Durak.sameCard(a,b)),0===this.state.playerCards[this.state.playerTurn].length&&this.state.endGame&&(this.state.gameOver=!0)):(this.state.cardsOnTable.push(b),this.state.playerCards[this.state.playerTurn]=this.state.playerCards[this.state.playerTurn].filter(a=>!Durak.sameCard(a,
b)),0===this.state.playerCards[this.state.playerTurn].length&&this.state.endGame?(this.state.winner=this.state.playerTurn,this.state.gameOver=!0):0===this.state.attackCards.length?(this.state.attackCards.push(b),this.state.playerTurn=0===this.state.playerTurn?1:0):1===this.state.attackCards.length?(this.state.attackCards.shift(),this.state.playerTurn=0===this.state.playerTurn?1:0):this.state.attackCards.shift())}}takeCards(b){function a(d,c){if(!c.endGame){var e=6-c.playerCards[d].length;for(let f=
0;f<e;f++)if(c.playerCards[d].push(c.deck[0]),c.deck.shift(),0===c.deck.length){if(null==c.lowerTrump){c.endGame=!0;break}c.deck.push(c.lowerTrump);c.lowerTrump=null}}}b?(6>this.state.playerCards[1].length&&a(1,this.state),6>this.state.playerCards[0].length&&a(0,this.state)):(6>this.state.playerCards[0].length&&a(0,this.state),6>this.state.playerCards[1].length&&a(1,this.state))}gameOver(){return this.state.gameOver}winner(){return this.state.winner}}
class Card{constructor(b,a){this.Value=b;this.Type=a}getValue(){return this.Value}getType(){return this.Type}};
